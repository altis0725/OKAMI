# 進化システムドキュメント

## 概要

OKAMI進化システムは、タスク実行結果を自動的に分析し、知識ファイルとYAML設定に改善を適用します。これにより、各相互作用から学習する自己改善型AIシステムが作成されます。

## 仕組み

### 1. 自動トリガー
- `main_crew`がタスクを完了すると、`evolution_crew`がバックグラウンドで自動的にトリガーされます
- クライアントは進化分析を待つことなく、すぐにレスポンスを受け取ります
- 進化分析は非同期で実行されます

### 2. 進化分析プロセス
```
main_crew 完了
    ↓
evolution_crew 分析
    ↓
改善の解析
    ↓
自動適用
    ↓
設定の再読み込み
```

### 3. 改善タイプ

#### 知識の改善
- **追加**: タスク結果に基づく新しい知識エントリ
- **更新**: 既存知識の修正
- **削除**: 古いまたは誤った情報

例:
```yaml
# knowledge/general.mdに自動追加
## 進化アップデート - 2025-01-16T10:30:00

新しい知識: Docker環境でのメモリ管理について...
```

#### エージェント設定
- 役割の調整
- 目標の改良
- バックストーリーの強化
- ツールの追加/削除

例:
```yaml
# config/agents/research_agent.yaml
role: "研究専門家"  # 進化により更新
goal: "検証済みのソースを含む包括的な研究を提供する"  # 強化
```

#### タスク設定
- 説明の改善
- 期待される出力の明確化
- ガードレールの調整

#### システム設定
- メモリ設定
- キャッシュ最適化
- プロセスタイプの変更

## APIエンドポイント

### 改善の取得
```bash
GET /improvements
```

まだ適用されていない保留中の改善を返します。

### 特定の改善を適用
```bash
POST /improvements/apply/{improvement_id}
```

IDによって特定の改善を手動で適用します。

### 改善履歴の取得
```bash
GET /improvements/history?limit=50
```

結果とともに適用された改善の履歴を表示します。

## 改善パーサー

`ImprovementParser`クラスは、進化クルーの出力を分析して実行可能な改善を抽出します：

1. **パターンマッチング**: 正規表現パターンを使用して改善提案を識別
2. **構造化抽出**: 番号付きリストとセクションを解析
3. **カテゴリ分類**: 改善を知識、エージェント、タスク、設定に分類

## 改善適用器

`ImprovementApplier`クラスは、解析された改善をファイルに適用します：

1. **バックアップ作成**: 変更前にタイムスタンプ付きバックアップを作成
2. **インテリジェント更新**: ファイルタイプ（YAML、Markdownなど）に基づいて変更を適用
3. **アトミック操作**: すべての変更が成功するか、何も適用されません
4. **設定の再読み込み**: 重要な変更後にクルーを自動的に再読み込み

## バックアップと復元

すべての変更されたファイルは、タイムスタンプとともに`evolution/backups/`にバックアップされます：
```
evolution/backups/
├── general.md.20250116_103045.bak
├── main_crew.yaml.20250116_103046.bak
└── research_agent.yaml.20250116_103047.bak
```

バックアップを復元するには：
```python
improvement_applier.restore_backup("config/agents/research_agent.yaml")
```

## 設定

進化の動作は`config/crews/evolution_crew.yaml`でカスタマイズできます：

```yaml
evolution_crew:
  name: "進化クルー"
  process: "sequential"
  memory: true
  cache: true
  agents:
    - evolution_agent
  tasks:
    - evolution_task
```

## ベストプラクティス

1. **進化結果のレビュー**: 定期的に`/improvements`をチェック
2. **アプリケーションの監視**: `/improvements/history`を使用して変更を追跡
3. **重要なファイルのバックアップ**: 主要な操作前に手動バックアップ
4. **変更のテスト**: 改善が機能を壊さないことを確認
5. **段階的な適用**: 改善を段階的に適用

## 例

### 進化結果の例
```
タスク実行の分析：

1. 識別された知識ギャップ：
   - 知識を追加: Docker composeネットワーキングの詳細
   - 知識を更新: メモリ管理のベストプラクティス

2. エージェントの改善：
   - research_agent: ソース検証を含むように目標を強化
   - analysis_agent: データ視覚化ツールを追加

3. タスクの最適化：
   - main_task: 期待される出力形式を明確化
   - evolution_task: 分析の深さを増加

4. 設定の提案：
   - すべてのクルーでキャッシュを有効化
   - パフォーマンス向上のためメモリ設定を調整
```

### 適用された変更の例
```json
{
  "applied": [
    {
      "file": "knowledge/general.md",
      "action": "add",
      "status": "applied",
      "content_added": 256
    },
    {
      "file": "config/agents/research_agent.yaml",
      "action": "update_field",
      "status": "applied",
      "field": "goal",
      "new_value": "検証済みのソースを含む包括的な研究を提供する"
    }
  ],
  "failed": [],
  "skipped": []
}
```

## モニタリング

WebUIは以下を表示します：
- 保留中の改善数
- 進化ステータスを含むタスク実行
- 適用された改善の履歴

## トラブルシューティング

### 改善が適用されない
- 解析エラーのログを確認
- ファイルのパーミッションを確認
- 有効なYAML/Markdown構文を確保

### 設定が再読み込みされない
- 変更されたファイルの構文エラーを確認
- クルーファクトリーの初期化を確認
- エラーログをレビュー

### バックアップの復元
- `evolution/backups/`で利用可能なバックアップをリスト
- タイムスタンプを使用して特定のバージョンを復元
- ファイルの差分で復元を確認